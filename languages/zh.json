{
  "route": {
    "about": "關於本站",
    "packages": "套件",
    "languages": "多語言切換器",
    "validator": "驗證器"
  },
  "about": {
    "description": "我在嘗試開發一些對於前對開發有幫助的套件。這些套件是純 JavaScript 開發，之所以在名稱上賦予 \"prototype-\" 的前綴，是因為在設計上我期待這些套件，能應用於其他 JavaScript 衍伸的開發框架，例如：React, Vue, ...等。如果這些套件在使用上有什麼困難，或者對於套件的開發有其他的想法或期待，還請多多與我分享您的想法。",
    "donate": {
      "1": "如果您喜歡 BTB Lab. 的開發成果與設計方式。您的",
      "2": "小小捐款",
      "3": "是給予我莫大的肯定與鼓勵。"
    }
  },
  "package": {
    "version_colon": "發布版本：",
    "release_colon": "發布日期：",
    "secation": {
      "title": {
        "installation": "安裝",
        "application": "應用"
      }
    },
    "languages": {
      "description": "對於跨國性服務來說，多國語言的支援往往是基本需求，雖然我們已有一些很出色的語言相關套件，如i18n，但我想開發的多語言切換器，主要是想降低套件的依賴性，以及降低一些非必要的功能支援，以最單純的核心功能，並且提供良好的擴充彈性，如果您需要很完整、方便的功能，可以考慮使用 i18n 之類的傑出套件，倘若需要的功能並不複雜，那麼也許你會想要試試看BTB Lab. 的多語言切換器。它也可以很輕易地應用在其他 JavaScript 衍生的開發框架。如 React, Vue, ...。",
      "block": {
        "initializer": {
          "title": "初始化",
          "description": {
            "initial": "在使用套件前，我們需要先初始化套件。初始的動作就是先定義出一個語言清單，並將每一個語言都先定義成一個物件，如：{ index: '', label: '', dictionary: {...} }。",
            "nest": "在版本 1.1.0 之後，多語言切換器支援巢狀的字典定義，以方便開發的時候整理字典集，當然這並不強迫，也可以依使用需求與習慣。將之定義成較扁平的字典集。",
            "result": "當時執行 languages.translate('a.aa.aaa') 結果為 'AAA' ，而當執行 languages.translate('b.ba') 結果則是 'BA'。而當輸入的內容無法查找對應的翻譯時，輸出的文字則為輸入值，如同 languages.translate('notFound') 結果為 'notFound' 一般。"
          }
        },
        "methods": {
          "title": "應用方法",
          "description": {
            "configuration": "再建完一個多語言切換器的實體之後，我們就可以利用裡面的函數來完善網站的多語言切換的支援，而實體的預設語言是初始化時，所設定清單裡的第一個語言。",
            "introduction": "接下來我們可以利用下列內建於多語言切換器的函數。"
          },
          "menu": "// 返回多語言切換器裡的語言清單，主要可用於實踐語言切換的選單。",
          "get": "// 返回目前選用的語言。",
          "set": "// 設定新選用的語言後，並返回該語言的物件。請記得設定完後要更新網頁的繪製(render)，以利translate()能使用新選用語言的字典。",
          "translate": "// 返回文字的對應翻譯，而其中還提供一個取代的功能，以利有些翻譯內文字可能包含變數。"
        }
      }
    },
    "validator": {
      "description": "大多數的排版框架皆含有驗證表單的功能，但各自排版框架的驗證器使用方式不盡相同，對於有些需要對於不同的案子，使用不同的排版框架的團隊而言，已經存在的驗證邏輯在移植上，可能就不是這麼方便，因此，我試著開發一般化的表單驗證器，或者可以更深一層地說它是變數驗證器，因為即使不與排版框架合用，單純寫在函數裡的變數格式驗證也是可以的，如此期望，應用此套件的人，可以一致地整合表單的驗證與函數的驗證。",
      "block": {
        "event": {
          "title": "事件驗證邏輯",
          "description": {
            "example": "為了一般性的設計，驗證器的設計對象為「事件」，而非如一般設計對象為「表單欄位」，換句話說，是因為什麼事件而執行這個驗證的概念設計此驗證器，因此這個驗證器中，所定義之驗證邏輯是由「事件」對應「驗證邏輯」與「驗證結果」。",
            "structure": "結構裡的鍵都被定義成事件代號，而鍵所對應的值定義為驗證邏輯的清單，換言之，我們可以透過一系列的邏輯驗證來確保對象值為我們想要得值，或者格式。由於驗證器是以事件為出發點，所以可以對想要的表單綁定對應驗證事件，或者在函數邏輯裡直接對想要的值做邏輯驗證，我們也可以對不同得值使用同一個邏輯事件做檢查，不管是共用同一個驗證事件，或者不同驗證事件共用同一個驗證邏輯。",
            "type": "驗證器本身亦有內建支援一些簡單的驗證邏輯。"
          },
          "rule": "邏輯驗證的設定包含邏輯種類與參數。" ,
          "message": "驗證失敗時的訊息。",
          "ruleType": {
            "type": "驗證值的類別。",
            "stringLength": "驗證文字的長度區間介於給定的 min 與 max 。我們也可以單獨只給 min 或 max 如同 'length|min:4'.",
            "absoluteLength": "驗證文字的指定長度。",
            "numericRange": "驗證數值介於 min 與 max 。我們也可以單獨只給 min 或 max 如同 'range|min:4'.",
            "absoluteValue": "驗證數值的指定值。",
            "format": "支援檢查格式：電子信箱、文字化數值、純文字、IP地址、Mac地址。"
          }
        },
        "methods": {
          "title": "應用方法",
          "description": {
            "implement": "首先實踐驗證器的在想要的地方。",
            "introduction": "在定義完驗證事件與驗證邏輯的對照表之後，驗證器提供一些方法做應用。"
          },
          "init": "// 初始化驗證器的驗證事件與驗證邏輯的對照表，如此驗證器才能初始化驗證事件對應的狀態值。",
          "status": "// 當執行 Status() 時，返回的是所有驗證事件的狀態，而執行 status(event) 則是返回特定驗證事件的狀態值。",
          "reset": "// 清空驗證事件的驗證狀態。",
          "validate": "// 觸發驗證。"
        },
        "status": {
          "title": "驗證狀態",
          "description": {
            "structure": "每一個驗證事件的驗證狀態的物件結構。",
            "state": "每一個驗證事件的狀態包含 null, false, true 。而 null 表示尚未觸發驗證的狀態。"
          }
        }
      }
    }
  }
}