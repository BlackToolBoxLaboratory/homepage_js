{
  "route": {
    "about": "About",
    "packages": "Packages",
    "languages": "Languages",
    "validator": "Validator"
  },
  "about": {
    "description": "I aim to develope some useful tool for front-end development. And they are based on JavaScript only so we could use them into some other JavaScript frameworks. And they are called \"prototype-\" as their prefix means we can use them with React, Vue, ... so on. While using, if you find some questions, bugs or issues. Or having some ideas. Please feel free to let me know.",
    "donate": {
      "1": "If you like all the works in BTB Lab. Please ",
      "2": "buy me a coffee",
      "3": "."
    }
  },
  "package": {
    "version_colon": "Version: ",
    "release_colon": "Release Date: ",
    "section": {
      "title": {
        "installation": "INSTALLATION",
        "application": "APPLICATION"
      }
    },
    "languages": {
      "description": "For developing the web-side of international services, we usually have the requirement to develop with the feature of multiple-languages supported. We already have a lot of masterpice such like i18n. But here we created our own multiple-languages package for lowing down the dependencies. And after adding a little code, we can apply it with other javascript frameworks like React, Vue ... and so on.",
      "block": {
        "initializer": {
          "title": "Initializer",
          "description": {
            "initial": "Before to use, we have to initialize. The input is an Array and the structure of each entry is { index: '', label: '', dictionary: {...} } as each language.",
            "nest": "After v1.1.0, it is supported to use nest-structure dictionary which means we can defined.",
            "result": "Then, languages.translate('a.aa.aaa') will be 'AAA' and languages.translate('b.ba') will be 'BA'. And while can not finding its string, it will response the key path as our input. like languages.translate('notFound') will be 'notFound'."
          }
        },
        "methods": {
          "title": "Methods",
          "description": {
            "configuration": "We can begin to use after to create a instance from Language. The default language is the first in the initializerconfig.",
            "introduction": "Then, we have some methods inside the Language."
          },
          "menu": "// To list out the menu of languages, for you can render a language list as a selector likely.",
          "get": "// To get the current language.",
          "set": "// To set new language Index as current language. Do not forget to update rendering, and then all translate() will be with the new setting.",
          "translate": "// To translate string by the current language. And the repacement is optional input."
        }
      }
    },
    "validator": {
      "description": "Most form UI packages have their own validator to use for convenience. But sometimes we don't use only one UI packages to develop every single project. So we try to create the validator generally to adapt to every kind of form UI packages to allow us using just one type of validator coding patteren to develop with every UI packages.",
      "block": {
        "event": {
          "title": "Event Rules",
          "description": {
            "example": "The validator is designed as a validator for 'event' which means it is not design for 'form'. So it do not bind with form and only triggered by event or function. For this, we need defined the event rule map as follow for example as following.",
            "structure": "Every key name under rule are named with the concept of event, and they are also Array type which means we can have a list to make sure the values are actually we need. Every check rule can have their message. Cause the rule are defined in event angle. So we can execute when we need or different value validated with same rule depending on the user's design.",
            "type": "Now we support some rule."
          },
          "rule": "Rule config included type and parameters." ,
          "message": "Message for while fail.",
          "ruleType": {
            "type": "Check input's typeof.",
            "stringLength": "Check the string's length between min and max. Otherwise, we can check min or max only like 'length|min:4'.",
            "absoluteLength": "Check the string's absolute length like string.length === absLength.",
            "numericRange": "Check the number's range between min and max. Otherwise, we can check min or max only like 'range|min:4'.",
            "absoluteValue": "Check the number's absolute value like number === absValue.",
            "format": "Supported: email, numeric, literal, ivp4, mac"
          }
        },
        "methods": {
          "title": "Methods",
          "description": {
            "implement": "Firstly we have to implement it, when we want to use the validator.",
            "introduction": "And after defined the event-rule-map, we have some methods for using."
          },
          "init": "// To put our event-rule-map into the Validator to init it meanwhile create the status for each event rule.",
          "status": "// Status() means get all status, and status(event) means to get the status of event we want.",
          "reset": "// Reset the status of events.",
          "validate": "Validate the value while event triggered."
        },
        "status": {
          "title": "Status",
          "description": {
            "structure": "The structure of status for each event.",
            "state": "Every event could be the three type of status: null, false, true. And null means the status is initialized."
          }
        }
      }
    }
  }
}